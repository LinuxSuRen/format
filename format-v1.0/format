#!/bin/bash

# Spida Software
# Nick Joodi
#
# A command line feature for the formatters
# To add more languages to be formatted, see extension.cfg located in the conf directory.

# Display the options
usage() { echo "Usage: $(basename $0) [options] <file or directory with relative path>"
          echo "    h:       print this message"
          echo "    b:       create a backup file"
          echo "    r:       format all files recursively starting from the directory specified" 
          echo "    g:       format all modified files in the git working directory"
          echo "    - r and g can not be set together"
          echo "    - g does not need a filename as an argument"
          exit 1;
}

# arrays that will contain the identifing marker to determine which formatter to use and also
# arrays containing the command to use when the identifying marker has been found
initializeArrays() {
    i=0
    while read line; do
        if [[ "$line" =~ ^[^#]*= ]]; then
        nameExtension[i]=${line%% =*}
        valueExtension[i]=${line#*= }
        ((i++))
    fi
    done <"${FORMAT}/conf/extension.cfg"

    i=0
    while read line; do
        nameHash[i]=${line%% =*}
        valueHash[i]=${line#*= }
        ((i++))
    done <"${FORMAT}/conf/hashBang.cfg"
}

# A one argument method that takes a file and creates a backup file
backup() {
    if [ $BACKUP = 1 ] ; then
        DATE=$(date +"%Y_%m_%d_%H_%M_%S")
        newName="${2}${1}_BACKUP_${DATE}"
        cp "${2}${1}" ${newName}
        echo "A backup file was stored in $newName"   
    fi 
}


# a method to determine if the format command was called in a git repository
isGitRepo() {
    if [ -d .git ]; then
        folder=$(echo .git)
    else
        folder=$(basename "$(git rev-parse --git-dir 2> /dev/null;)")
    fi;
    if [ "${folder}" != ".git" ] ; then
        echo "*** Need to be located in a git repository ***"
        exit 1
    fi
}

# Format by using the extension of the file
formatByExtension() {
    i=0
    while [ $i -lt $(eval "echo ${#nameExtension[@]}") ] ; do
        if [[ "${1##*.}" = "${nameExtension[$i]}" ]]  && [[  -e "${2}${1}" ]]; then
            $(eval "echo ${valueExtension[$i]}") "${2}${1}"
            backup "${1}" "${2}"
        fi
        i=$[$i+1]
    done 
}

# format by using the first line of code in the file
formatByHashBang() {
read -r firstLine<"${2}${1}"
i=0
while [ $i -lt $(eval "echo ${#nameHash[@]}") ] ; do
    if [[ "${firstLine}" == *"${nameHash[$i]}"* ]]  && [[  -e "${2}${1}" ]]; then
        $(eval "echo ${valueHash[i]}") "${2}${1}"
        backup "${1}" "${2}"
    fi
    i=$[$i+1]
done
}

# this method will format one file
format() {
    i=${1}
    filename=$(basename "$1")
    if [[ $filename = [!.]*.* ]] ; then
        formatByExtension "$1" "$2"
    elif [ ! -d "${2}${1}" ] ; then
        formatByHashBang "$1" "$2"
    fi
}

# A one argument method that takes a directory and formats all files in a directory and the
# files in the respective subdirectories
recursive() {
    echo "*** Are you sure you want to recursively format all files? (enter y to continue) ***"
    read answer
    if [ ${answer} = y ] ; then
        echo "****************************************************************************"
        echo "I'd recommend that you (if you haven't already done so) set the backup flag."
        echo "If you haven't, would you like to terminate this command so that you can add"
        echo "the backup flag?                                                            "
        echo "(enter n to continue, enter y to terminate)                                 "
        echo "****************************************************************************"
        read backupFlag
        if [ ${backupFlag} = n ] ; then
            for entry in $(find ${1}) ; do
                format "${2}${entry}"
            done
        else
            exit 1
        fi
    else
        exit 1
    fi
}

# Format all modified files in a git repository
gitFormat() {
    isGitRepo
    filenames=$(git diff --name-only)
    for i in $filenames ; do
        path=$(git rev-parse --show-toplevel)
        cd $path
        if  [  -e "${i}"  ] ; then
            format "${i}"
        fi
    done
}

# Flags for the options
BACKUP=0
RECURSIVE=0
GIT=0
GROOVY=0
initializeArrays

# Using getopts to parse the command line arguments
while getopts ":brg" o; do
    case "${o}" in
        b)
            BACKUP=1
            ;;
        r)
            RECURSIVE=1
            ;;
        g)  
            GIT=1
            ;;
        *)
            usage
            ;;
    esac
done
shift $((OPTIND-1))

File=$1
if [ ${GIT} = 1 ] ; then
    gitFormat
elif [ $# != 1 ] ; then 
    echo "invalid execution of format";
    usage
    exit 1
elif  [ -d "${File}" ] ; then
    if [ ${RECURSIVE} = 1 ] ; then
        recursive "${File}"
    else
        for entry in $(ls ${File}) ; do
            format "${entry}" "${File}/"
        done
    fi
else
    if [ -f "${File}" ]; then
        format "${File}"
    else
        echo "${File} is not valid";
        exit 1
    fi
fi





