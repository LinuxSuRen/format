#!/bin/bash

# Spida Software
# Nick Joodi
#
# This script will automatically format files. 
# To add more formatters to this script, see the format() method.

# Display the options
usage() { echo "Usage: $(basename $0) [options] <file or directory with relative path>"
          echo "    h:       print this message"
          echo "    b:       create a backup file"
          echo "    r:       format all files recursively starting from the directory specified" 
          echo "    g:       format all modified files in the git working directory"
          echo "    - r and g can not be set together"
          echo "    - g does not need a filename as an argument"
          exit 1;
}

# A one argument method that takes a file and creates a backup file
backup() {
    if [ $BACKUP = 1 ] ; then
        DATE=$(date +"%Y_%m_%d_%H_%M_%S")
        newName="${2}${1}_BACKUP_${DATE}"
        cp "${2}${1}" ${newName}
        echo "A backup file was stored in $newName"   
    fi 
}

# A method to determine if the file is a groovy script
isGroovy() {
    GROOVY=0
    if [ ! -d "${1}" ] && [[ "${parseHeader}" = 1 ]] ; then
        read -r firstLine<"${2}${1}"
        if [[ "${firstLine}" == *#!/usr/bin/env\ groovy* ]] ; then
          GROOVY=1
        fi
    fi
}

# a method to determine if the format command was called in a git repository
isGitRepo() {
    if [ -d .git ]; then
        folder=$(echo .git)
    else
        folder=$(basename "$(git rev-parse --git-dir 2> /dev/null;)")
    fi;
    if [ "${folder}" != ".git" ] ; then
        echo "*** Need to be located in a git repository ***"
        exit 1
    fi
}

# A one argument method that takes a file to Format.
# This method is where you add a new formatter. Just add a new if statement
# that checks the extensions of the files that can be formatted with this new formatter.
# Inside the if, give the command to format one file without a backup. This command must
# beable to execute from the path where this script is located. Below that line, 
# then add a call to the backup function with the first parameter being the file name.
format() {
    i=${1}
    isGroovy "${i}" "${2}"
    if [[ "${i##*.}" = "groovy" || "${i##*.}" = "java" || "${GROOVY}" = 1 ]]  && [[  -e "${2}${1}" ]]; then
        java -jar ${FORMAT}/EclipseFormatter/target/EclipseFormatter.jar "${2}${1}"
        backup "${1}" "${2}"

    fi
}

# A one argument method that takes a directory and formats all files in a directory and the
# files in the respective subdirectories
recursive() {
    echo "*** Are you sure you want to recursively format all files? (enter y to continue) ***"
    read answer
    if [ ${answer} = y ] ; then
        echo "****************************************************************************"
        echo "I'd recommend that you (if you haven't already done so) set the backup flag."
        echo "If you haven't, would you like to terminate this command so that you can add"
        echo "the backup flag?                                                            "
        echo "(enter n to continue, enter y to terminate)                                 "
        echo "****************************************************************************"
        read backupFlag
        if [ ${backupFlag} = n ] ; then
            for entry in $(find ${1}) ; do
                format "${2}${entry}"
            done
        else
            exit 1
        fi
    else
        exit 1
    fi
}

# Format all modified files in a git repository
gitFormat() {
    isGitRepo
    filenames=$(git diff --name-only)
    for i in $filenames ; do
        path=$(git rev-parse --show-toplevel)
        cd $path
        if  [  -e "${i}"  ] ; then
            format "${i}"
        fi
    done
}

# Flags for the options
BACKUP=0
RECURSIVE=0
GIT=0
GROOVY=0
parseHeader=1

# Using getopts to parse the command line arguments
while getopts ":brg" o; do
    case "${o}" in
        b)
            BACKUP=1
            ;;
        r)
            RECURSIVE=1
            ;;
        g)  
            GIT=1
            ;;
        *)
            usage
            ;;
    esac
done
shift $((OPTIND-1))

File=$1
if [ ${GIT} = 1 ] ; then
    parseHeader=0;
    gitFormat
elif [ $# != 1 ] ; then 
    echo "invalid execution of format";
    usage
    exit 1
elif  [ -d "${File}" ] ; then
    if [ ${RECURSIVE} = 1 ] ; then
        parseHeader=0;
        recursive "${File}"
    else
        for entry in $(ls ${File}) ; do
            parseHeader=0
            format "${entry}" "${File}/"
        done
    fi
else
    if [ -f "${File}" ]; then
        format "${File}"
    else
        echo "${File} is not valid";
        exit 1
    fi
fi





